<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ProductiveRage.Immutable</name>
    </assembly>
    <members>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.CtorSet``2(``0,System.Func{``0,``1},``1)">
            <summary>
            This will take a source reference, a lambda that identifies the getter of a property on the source type and a new value to set that reference's property to - it will
            try to set the property to the new value. This requires that the propertyIdentifier is, in fact, a simple lambda to a getter and that a setter exists that follows
            the naming convention of the getter (so if the getter is called getName then a setter must exist called setName). If these conditions are not met then an exception
            will be thrown. It is not acceptable for any of the arguments to be null - if the property must be nullable then it should have a type wrapped in an Optional
            struct, which will ensure that "value" itself will not be null (though it may represent a "missing" value). Once a property has been set once, it may not be
            set again - it is "locked". Subsequent attempts to change it will result in an exception being thrown. THIS SHOULD ONLY BE CALLED FROM WITHIN CONSTRUCTORS
            AND THOSE CONSTRUCTOR SHOULD EXPLICITLY SET EVERY PROPERTY - that will result in every property being lock into its initial state and any attempt by an
            external reference to change property values will result in an exception being thrown. Note: Because this function could be used to set private state
            on a reference (if that reference did not lock all of the properties in its constructor) then it will only operate against types that implement the
            IAmImmutable interface - this is an empty interface whose only purpose is to identify a class that has been designed to work with this process.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.GetProperty``2(``0,System.Func{``0,``1})">
            <summary>
            There are analysers to ensure that the IAmImmutable.With extension method is only called with lambdas that match the required format (the lambdas must be a simple
            property access for a property that has a getter and setter and that doesn't have any special translation rules applied via Bridge attributes). However, sometimes
            it is useful to be able to pass references to these lambdas around, which is problematic with the analyser that checks the propertyIdentifier argument of all calls
            to the With method. To workaround this, a property identifier reference may be created using this method and then passed into the With method - note that all of the
            same validation rules are applied to GetProperty as to With, so it must still be a simple property-access lambda (but now a lambda reference may be created once and
            shared or passed around). Note that the source argument here is only present so that this may exist as an extension method and to make the code more succinct when
            working with an IAmImmutable reference already (it will be possible to use type inference to save having to explicitly specify the T and TPropertyValue type params
            but the returned PropertyIdentifier will not be tied to the source instance).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.GetProperty``2(System.Func{``0,``1})">
            <summary>
            There are analysers to ensure that the IAmImmutable.With extension method is only called with lambdas that match the required format (the lambdas must be a simple
            property access for a property that has a getter and setter and that doesn't have any special translation rules applied via Bridge attributes). However, sometimes
            it is useful to be able to pass references to these lambdas around, which is problematic with the analyser that checks the propertyIdentifier argument of all calls
            to the With method. To workaround this, a property identifier reference may be created using this method and then passed into the With method - note that all of the
            same validation rules are applied to GetProperty as to With, so it must still be a simple property-access lambda (but now a lambda reference may be created once and
            shared or passed around).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,System.Func{``0,``1},``1)">
            <summary>
            This will take a source reference, a lambda that identifies the getter of a property on the source type and a new value to set for that property - it will try to
            clone the source reference and then change the value of the indicated property on the new reference. The same restrictions that apply to "CtorSet" apply here (in
            terms of the propertyIdentifier having to be a simple property retrieval and of the getter / setter having to follow a naming convention), if they are not met then
            an exception will be thrown. Note that if the new property value is the same as the current property value on the source reference then this process will be skipped
            and the source reference will be passed straight back out. The new property value may not be null - if the property must be nullable then it should have a type
            wrapped in an Optional struct, which will ensure that "value" itself will not be null (though it may represent a "missing" value).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,ProductiveRage.Immutable.PropertyIdentifier{``0,``1},``1)">
            <summary>
            This will take a source reference, a property identifier for a property on the source type and a new value to set for that property - it will try to clone the source
            reference and then change the value of the indicated property on the new reference. Note that if the new property value is the same as the current property value on
            the source reference then this process will be skipped and the source reference will be passed straight back out. The new property value may not be null - if the property
            must be nullable then it should have a type wrapped in an Optional struct, which will ensure that "value" itself will not be null (though it may represent a "missing"
            value).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,ProductiveRage.Immutable.PropertyIdentifier{``0,``1},System.Func{``1,``1})">
            <summary>
            This will take a source reference, a property identifier for a property on the source type and a lambda that will receive the current value and return a new one. It will
            try to clone the source reference and then change the value of the indicated property on the new reference. An exception will also be thrown if the valueUpdater delegate
            returns null - if the property must be nullable then it should have a type wrapped in an Optional struct, which will ensure that "value" itself will not be null (though
            it may represent a "missing" value). Note that if the new property value is the same as the current property value on the source reference then no clone will be performed
            and the source reference will be passed straight back out.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,System.Func{``0,``1},System.Func{``1,``1})">
            <summary>
            This will take a source reference, a lambda that identifies the getter of a property on the source type and a lambda that will receive the current value and return
            a new one. It will try to clone the source reference and then change the value of the indicated property on the new reference. The same restrictions that apply to
            "CtorSet" apply here (in terms of the propertyIdentifier having to be a simple property retrieval and of the getter / setter having to follow a naming convention),
            if they are not met then an exception will be thrown. An exception will also be thrown if the valueUpdater delegate returns null - if the property must be nullable
            then it should have a type wrapped in an Optional struct, which will ensure that "value" itself will not be null (though it may represent a "missing" value). Note
            that if the new property value is the same as the current property value on the source reference then no clone will be performed and the source reference will be
            passed straight back out.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,System.Func{``0,ProductiveRage.Immutable.Set{``1}},System.UInt32,``1)">
            <summary>
            This will take a source reference, a lambda that identifies the getter of a property on the source type that is a Set, an index that must exist within the current
            value for the specified property on the source reference and a new value to set for that property - it will try to clone the source reference and then change the
            value of the element at the specified index on the indicated property on the new reference. The same restrictions that apply to "CtorSet" apply here (in terms of
            the propertyIdentifier having to be a simple property retrieval and of the getter / setter having to follow a naming convention), if they are not met then an
            exception will be thrown. Note that if the new value is the same as the current value then this process will be skipped and the source reference will be passed
            straight back out. The new property value may not be null - if the property must be nullable then it should have a type wrapped in an Optional struct, which will
            ensure that "value" itself will not be null (though it may represent a "missing" value).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,System.Func{``0,ProductiveRage.Immutable.NonNullList{``1}},System.UInt32,``1)">
            <summary>
            This will take a source reference, a lambda that identifies the getter of a property on the source type that is a NonNullList, an index that must exist within the
            current value for the specified property on the source reference and a new value to set for that property - it will try to clone the source reference and then change
            the value of the element at the specified index on the indicated property on the new reference. The same restrictions that apply to "CtorSet" apply here (in terms
            of the propertyIdentifier having to be a simple property retrieval and of the getter / setter having to follow a naming convention), if they are not met then an
            exception will be thrown. Note that if the new value is the same as the current value then this process will be skipped and the source reference will be passed
            straight back out. The new property value may not be null - if the property must be nullable then it should have a type wrapped in an Optional struct, which will
            ensure that "value" itself will not be null (though it may represent a "missing" value).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,System.Func{``0,ProductiveRage.Immutable.NonNullList{``1}},System.UInt32,System.Func{``1,``1})">
            <summary>
            This will take a source reference, a lambda that identifies the getter of a property on the source type that is a NonNullList, an index that must exist within the
            current value for the specified property on the source reference and a delegate that takes the current value for that list item and returns a replacement. The same
            restrictions that apply to "CtorSet" apply here (in terms of the propertyIdentifier having to be a simple property retrieval and of the getter / setter having to
            follow a naming convention), if they are not met then an exception will be thrown. Note that if the new value is the same as the current value then this process
            will be skipped and the source reference will be passed straight back out. The new property value may not be null - if the property must be nullable then it should
            have a type wrapped in an Optional struct, which will ensure that "value" itself will not be null (though it may represent a "missing" value).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,System.Func{``0,``1})">
            <summary>
            This will take a source reference and a lambda that identifies the getter of a property on the source type and it will try to return a lambda that will take a
            new value for the specified property and return a new instance of the source reference, with the property on the new instance set to the provided value. This
            is like a partial application of the With method that takes a value argument as well as a source and propertyIdentifier. The same restrictions apply as for
            "CtorSet" and the other "With" implementation - the propertyIdentifier must be a simple property retrieval and the property's getter and setter may not
            use a Bridge [Name] attribute. The returned lambda will throw an exception if called with a null value - if the property must be nullable then it should
            have a type wrapped in an Optional struct, which will ensure that "value" itself will not be null (though it may represent a "missing" value).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.With``2(``0,System.Func{``0,ProductiveRage.Immutable.Set{``1}},System.UInt32)">
            <summary>
            This will take a source reference, a lambda that identifies the getter of a property on the source type that is a Set and an index that must exist within the
            current value for the specified property on the source reference. It will try to return a lambda that will take a new value for the specified index within the
            specified Set property and return a new instance of the source reference, with that element update. This is like a partial application of the With method that
            takes a value argument as well as a source, propertyIdentifier and index. The same restrictions apply as for "CtorSet" and the other "With" implementation -
            the propertyIdentifier must be a simple property retrieval and the property's getter and setter may not use a Bridge [Name] attribute (if any of these conditions
            are not met then an argument exception will be thrown, as is the case if an invalid index is specified). The returned lambda will throw an exception if called
            with a null value - if the property must be nullable then it should have a type wrapped in an Optional struct, which will ensure that "value" itself will not
            be null (though it may represent a "missing" value).
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.GetSetter``2(``0,System.Func{``0,``1})">
            <summary>
            This will get the setter delegate from cache if available - if not then it will construct a new setter, push it into the cache and then return it
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.ImmutabilityHelpers.ValidateAfterUpdateIfValidateMethodDefined``1(``0)">
            <summary>
            If there is an argument-less Validate method on the instance then call that (this is to make up for the fact that the constructor is not called after properties are updated)
            </summary>
        </member>
        <member name="T:ProductiveRage.Immutable.IAmImmutable">
            <summary>
            The CtorSet extension method should only be used with types that are intended for its use so it will only operate against classes the implement this interface. The
            interface itself is empty, it is just to identify the for-use-with-CtorSet types (and the only thing to bear in mind with that is that properties should all be set
            for the instance within the constructor so that they can not later be altered externally, with CtorSet would allow for properties that had NOT been set in a ctor).
            </summary>
        </member>
        <member name="T:ProductiveRage.Immutable.ReadOnlyAttribute">
            <summary>
            This may be applied to a property on an IAmImmutable implementation to indicate that it may not be updated via the 'With' function. It does not make sense on types that do not
            implement IAmImmutable because 'With' does not apply to those. This may be used to allow properties on IAmImmutable implementations which are computed, rather than being simple
            auto-properties (which is what is otherwise required) or it may be useful if a type should only be initialised in a particular and some properties should not be changed after
            being first created (in which case it would make sense for its constructors to be private and for static factory methods to be defined to ensure that instances are created
            to follow whatever patterns are required). Properties annotated with this attribute must still follow all of the other IAmImmutable property rules because it will still
            be settable by 'CtorSet' calls.
            </summary>
        </member>
        <member name="T:ProductiveRage.Immutable.PropertyIdentifierAttribute">
            <summary>
            This attribute may be used a way to pass a Property Identifier reference from one method to another (and then on to the IAmImmutable With extension method). When an argument
            has this attribute on it, the caller must always provide a lambda that meets the same criteria as calls to With (or CtorSet or GetProperty) - it must be a simple lambda that
            references a simple property on an IAmImmutable target. Method arguments that have this attribute on may not be reassigned within the method since could bypass the performed
            validation (and it might not be possible to ensure that the new value meets the required criteria).
            </summary>
        </member>
        <member name="T:ProductiveRage.Immutable.PropertyIdentifier`2">
            <summary>
            This class allows a property identifier reference to be created and then passed into the With extension method. The validation that would be applied to the With
            call will be bypassed if a PropertyIdentifier is provided (instead of a Func) because the same validation is applied to the GetProperty extension method, which
            is the only way that an instance of this class may be created. 
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList.Of``1(``0[])">
            <summary>
            This will throw an exception for any null references in the values parameters - if nulls may be required then the type parameter should be an Optional
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.Insert(`0)">
            <summary>
            Due to the internal structure of this class, this is the cheapest way to add an item to a set. Null references are not allowed (an exception will be thrown),
            if you require values that may be null then the type parameter should be an Optional.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.Add(`0)">
            <summary>
            Due to the internal structure of this class, this is a more expensive operation that Insert (which inserts a new item at the start of the set, rather than at
            the end, which this function does).  Null references are not allowed (an exception will be thrown), if you require values that may be null then the type parameter
            should be an Optional.
            </summary>
        </member>
        <member name="P:ProductiveRage.Immutable.NonNullList`1.Item(System.UInt32)">
            <summary>
            This will throw an exception for an invalid index value. It will never return a null reference as this data type will not store null references - if nulls
            may be required then the type parameter should be an Optional.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.SetValue(System.UInt32,`0)">
            <summary>
            This will throw an exception for an invalid index value or for a null value reference. This data type will not store null references - if nulls may be required
            then the type parameter should be an Optional.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.Select``1(System.Func{`0,System.UInt32,``0})">
            <summary>
            Since the Set class uses uint for its index value, the standard LINQ indexed Select class requires a cast from int to uint - this version prevents that cast from
            being necessary
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.UpdateAll(System.Func{`0,`0})">
            <summary>
            This will return a new NonNullList of the same element type, where each item has been processed with the specified updater delegate. It is not valid for the updater
            to return a null reference, this data type will not store null references (if there may be missing values then the type parameter should be an Optional). If the
            set is empty or if the updater returns the same reference for every item then no change is required and the current Set reference will be returned unaltered.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.Update(System.Func{`0,`0},System.Func{`0,System.Boolean})">
            <summary>
            This will return a new NonNullList of the same element type, where any item that matches the specified filter will be processed with the specified updater delegate.
            It is not valid for the updater to return a null reference, this data type will not store null references (if there may be missing values then the type parameter
            should be an Optional). If the set is empty, if the filter does not match any items or if the updater returns the same reference for every matched item then
            no change is required and the current Set reference will be returned unaltered.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.Map``1(System.Func{`0,``0})">
            <summary>
            This will return a new NonNullList of different element type, where each item has processed with the specified mapper delegate. It is not valid for the mapper
            to return a null reference, this data type will not store null references (if there may be missing values then the type parameter should be an Optional). If
            none of the items are changed and TDest matches the item type of the current list then the current list will be returned unaltered.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.Map``1(System.Func{`0,System.UInt32,``0})">
            <summary>
            This will return a new NonNullList of different element type, where each item has processed with the specified mapper delegate. It is not valid for the mapper
            to return a null reference, this data type will not store null references (if there may be missing values then the type parameter should be an Optional). If
            none of the items are changed and TDest matches the item type of the current list then the current list will be returned unaltered.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.RemoveAt(System.UInt32)">
            <summary>
            This will throw an exception for an invalid index value or for a null value reference
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.Remove(System.Func{`0,System.Boolean})">
            <summary>
            This will remove any items from the set that match the specified filter. If no items were matched then the initial set will be returned unaltered.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.NonNullList`1.EnumerateClonedNodeWrappedItems">
            <summary>
            This returns an enumerable of Node instances where the Item property is set but not the Count or NextIfAny (this is only useful within the OrderBy implementation, which
            will set those properties on the cloned Nodes after rearranging them - ordinarily )
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set.Of``1(``0[])">
            <summary>
            This will throw an exception for any null references in the values parameters - if nulls may be required then the type parameter should be an Optional
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.Insert(`0)">
            <summary>
            Due to the internal structure of this class, this is the cheapest way to add an item to a set. Null references are not allowed (an exception will be thrown),
            if you require values that may be null then the type parameter should be an Optional.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.Add(`0)">
            <summary>
            Due to the internal structure of this class, this is a more expensive operation that Insert (which inserts a new item at the start of the set, rather than at
            the end, which this function does).  Null references are not allowed (an exception will be thrown), if you require values that may be null then the type parameter
            should be an Optional.
            </summary>
        </member>
        <member name="P:ProductiveRage.Immutable.Set`1.Item(System.UInt32)">
            <summary>
            This will throw an exception for an invalid index value. It will never return a null reference as this data type will not store null references - if nulls
            may be required then the type parameter should be an Optional.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.SetValue(System.UInt32,`0)">
            <summary>
            This will throw an exception for an invalid index value or for a null value reference. This data type will not store null references - if nulls may be required
            then the type parameter should be an Optional.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.Select``1(System.Func{`0,System.UInt32,``0})">
            <summary>
            Since the Set class uses uint for its index value, the standard LINQ indexed Select class requires a cast from int to uint - this version prevents that cast from
            being necessary
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.UpdateAll(System.Func{`0,`0})">
            <summary>
            This will return a new Set of the same element type, where each item has been processed with the specified updater delegate. It is not valid for the updater to
            return a null reference, this data type will not store null references (if there may be missing values then the type parameter should be an Optional). If the
            set is empty or if the updater returns the same reference for every item then no change is required and the current Set reference will be returned unaltered.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.Update(System.Func{`0,`0},System.Func{`0,System.Boolean})">
            <summary>
            This will return a new Set of the same element type, where any item that matches the specified filter will be processed with the specified updater delegate. It
            is not valid for the updater to return a null reference, this data type will not store null references (if there may be missing values then the type parameter
            should be an Optional). If the set is empty, if the filter does not match any items or if the updater returns the same reference for every matched item then
            no change is required and the current Set reference will be returned unaltered.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.RemoveAt(System.UInt32)">
            <summary>
            This will throw an exception for an invalid index value or for a null value reference
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Set`1.Remove(System.Func{`0,System.Boolean})">
            <summary>
            This will remove any items from the set that match the specified filter. If no items were matched then the initial set will be returned unaltered.
            </summary>
        </member>
        <member name="P:ProductiveRage.Immutable.Optional`1.Missing">
            <summary>
            Gets an instance that indicates the value was not specified.
            </summary>
        </member>
        <member name="P:ProductiveRage.Immutable.Optional`1.IsDefined">
            <summary>
            Gets a value indicating whether the value was specified.
            </summary>
        </member>
        <member name="P:ProductiveRage.Immutable.Optional`1.Value">
            <summary>
            Gets the specified value, or the default value for the type if <see cref="P:ProductiveRage.Immutable.Optional`1.IsDefined"/> is <c>false</c>.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Optional`1.Map``1(System.Func{`0,``0})">
            <summary>
            If this Optional instance has a value then the value will be transformed using the specified mapper. If this instance
            does not have a value or if the mapper returns null then a Missing Optional-of-TResult will be returned.
            </summary>
        </member>
        <member name="M:ProductiveRage.Immutable.Optional`1.op_Implicit(`0)~ProductiveRage.Immutable.Optional{`0}">
            <summary>
            Implicitly wraps the specified value as an Optional.
            </summary>
        </member>
    </members>
</doc>
